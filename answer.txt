def up(a):
    '''
    Увеличиваем вводимое двоичное число на 1, проверяем на переполнение

    :param a: двоичное число в формате list
    :return: true или false, в зависимости от наличия переполнения
    '''
    p = 1
    for i in range(len(a) - 1, -1, -1):
        if a[i] == '0':
            a[i] = '1'
            p = 0
            break
        else:
            a[i] = '0'
            p = 1
    return bool(p)

def solve(n, a, b):
    '''
    Решение задачи

    :param n: длина двоичных чисел
    :param a: первое число
    :param b: второе число
    :return: два двоичных числа, подходящие под условие задачи
    '''
    z = '0' * n # Создаем нулевое дв. число необходимой длины
    b_list = list(b)
    if not up(b_list): # Если нет переполнения. Второе число увеличено на 1
        p = 0 # Перенос
        p_index = -1  # Индекс переноса, если переносов не было - равен -1
        for i in range(n - 1, -1, -1): # Ищем справа налево разряд дв. числа, в котором в первом числе 0, во втором - 1, с учетом переноса
            if int(a[i]) + int(b_list[i]) + p > 1:
                p = 1
                p_index = i
            else:
                p = 0
        if p_index == -1:  # Если переносов не было - числа уже совместимы, возвращаем
            return a, ''.join(b_list)
        if p_index > 0:  # В ином случае получаем наименьшее второе число, совместимое с первым, на месте нужного разряда - единица, справа - нули
            b_list[p_index - 1] = '1'
            for i in range(p_index, n):
                b_list[i] = '0'
            return a, ''.join(b_list)
    # Если второе переполнено, либо не получилось найти совместимое с числом a число b
    a_list = list(a)
    if up(a_list):
        return z, z  # Если а переполнено, возвращаем 0, 0
    return ''.join(a_list), z  # Если а не переполнено, возвращаем его с b = 0

# Чтение входных данных
n = int(input())
a = input().strip()
b = input().strip()

# Решение
result = solve(n, a, b)

# Вывод результата
print(result[0])
print(result[1])